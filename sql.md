## Supabase schema for CalmCampus backup

Copyâ€“paste the statements below into the Supabase SQL editor to create tables that match the data used in the Flutter app and `SupabaseSyncService`.

```sql
-- Moods -----------------------------------------------------------------
create table public.moods (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  local_id integer, -- id from local SQLite

  date_time timestamptz not null,
  overall_mood text not null,
  main_theme_tag text not null,
  note text,
  extra_tags text[]
);

create unique index if not exists moods_user_local_id_idx
  on public.moods (user_id, local_id);


-- Classes / timetable ---------------------------------------------------
create table public.classes (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  local_id integer,

  subject text not null,
  day_of_week integer not null,
  start_time text not null,
  end_time text not null,
  location text not null,
  class_type text not null,
  lecturer text not null
);

create unique index if not exists classes_user_local_id_idx
  on public.classes (user_id, local_id);


-- Tasks -----------------------------------------------------------------
create table public.tasks (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  local_id integer,

  title text not null,
  subject text not null,
  due_date timestamptz not null,
  status text not null,
  priority text not null,
  created_at timestamptz not null
);

create unique index if not exists tasks_user_local_id_idx
  on public.tasks (user_id, local_id);


-- Journal entries -------------------------------------------------------
create table public.journal_entries (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  local_id integer,

  content text not null,
  created_at timestamptz not null
);

create unique index if not exists journal_entries_user_local_id_idx
  on public.journal_entries (user_id, local_id);


-- Sleep entries ---------------------------------------------------------
create table public.sleep_entries (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  local_id integer,

  date date not null,
  sleep_start timestamptz not null,
  sleep_end timestamptz not null,
  duration_hours double precision not null,
  restfulness integer not null
);

create unique index if not exists sleep_entries_user_local_id_idx
  on public.sleep_entries (user_id, local_id);


-- Period cycles ---------------------------------------------------------
create table public.period_cycles (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  local_id integer,

  cycle_start_date timestamptz not null,
  cycle_end_date timestamptz not null,
  period_duration_days integer not null,
  calculated_cycle_length integer
);

create unique index if not exists period_cycles_user_local_id_idx
  on public.period_cycles (user_id, local_id);


-- Support contacts ------------------------------------------------------
create table public.support_contacts (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  local_id integer,

  name text not null,
  relationship text not null,
  contact_type text not null,
  contact_value text not null,
  priority integer not null
);

create unique index if not exists support_contacts_user_local_id_idx
  on public.support_contacts (user_id, local_id);


-- Movement entries ------------------------------------------------------
create table public.movement_entries (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users (id) on delete cascade,
  local_id integer,

  date date not null,
  minutes integer not null,
  type text not null,
  intensity text not null,
  energy_before integer,
  energy_after integer,
  note text
);

create unique index if not exists movement_entries_user_local_id_idx
  on public.movement_entries (user_id, local_id);


-- Announcements (guest-friendly) --------------------------------------
create table public.announcements (
  id bigint generated by default as identity primary key,
  title text not null,
  summary text not null,
  body text not null,
  author text not null default 'DSA Wellness Desk',
  category text,
  published_at timestamptz not null default now()
);

-- If you want guests to read these updates, add a policy like:
-- alter table public.announcements enable row level security;
-- create policy "Announcements are readable by anyone" on public.announcements
--   for select using (true);
-- Optionally allow inserts from the app (for in-app posting):
-- create policy "Announcements can be added from app" on public.announcements
--   for insert with check (true);
-- Tip: keep deletes restricted to trusted roles.

-- Profiles (roles + consultant presence) ------------------------------
create table public.profiles (
  id uuid primary key references auth.users (id) on delete cascade,
  role text not null default 'student',
  display_name text,
  is_consultant boolean not null default false,
  is_online boolean not null default false,
  tags text[],
  updated_at timestamptz not null default now()
);

alter table public.profiles enable row level security;
create policy "User can manage own profile" on public.profiles
  for all using (auth.uid() = id) with check (auth.uid() = id);
create policy "Students can read consultants" on public.profiles
  for select using (role = 'admin');

-- Announcements (lock posting to admins)
create policy "Announcements readable by anyone" on public.announcements for select using (true);
create policy "Announcements insert by admins" on public.announcements
  for insert with check (exists (select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'));
create policy "Announcements delete by admins" on public.announcements
  for delete using (exists (select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'));

-- Live consultations (DSA <> student chat) ---------------------------
create table public.consultations (
  id bigint generated by default as identity primary key,
  student_id uuid not null references auth.users (id) on delete cascade,
  consultant_id uuid not null references auth.users (id) on delete cascade,
  status text not null default 'open',
  started_at timestamptz not null default now(),
  ended_at timestamptz
);

create table public.consultation_messages (
  id bigint generated by default as identity primary key,
  session_id bigint not null references public.consultations (id) on delete cascade,
  sender_id uuid not null references auth.users (id) on delete cascade,
  sender_role text not null,
  content text not null,
  sent_at timestamptz not null default now()
);

alter table public.consultations enable row level security;
alter table public.consultation_messages enable row level security;

create policy "Participants can see their consultations" on public.consultations
  for select using (
    auth.uid() = student_id or auth.uid() = consultant_id
  );
create policy "Students can create consultations" on public.consultations
  for insert with check (
    auth.uid() = student_id
  );
create policy "Consultants can update/close" on public.consultations
  for update using (
    auth.uid() = consultant_id
  ) with check (auth.uid() = consultant_id);
create policy "Participants can delete consultations" on public.consultations
  for delete using (
    auth.uid() = student_id or auth.uid() = consultant_id
  );

create policy "Participants can read messages" on public.consultation_messages
  for select using (
    exists (
      select 1 from public.consultations c
      where c.id = session_id and (auth.uid() = c.student_id or auth.uid() = c.consultant_id)
    )
  );
create policy "Participants can insert messages" on public.consultation_messages
  for insert with check (
    exists (
      select 1 from public.consultations c
      where c.id = session_id and (auth.uid() = c.student_id or auth.uid() = c.consultant_id)
    )
  );
create policy "Participants can delete messages" on public.consultation_messages
  for delete using (
    exists (
      select 1 from public.consultations c
      where c.id = session_id and (auth.uid() = c.student_id or auth.uid() = c.consultant_id)
    )
  );
```
